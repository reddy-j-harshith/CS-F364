{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\User\\\\OneDrive\\\\Acads 3-2\\\\DAA\\\\Project\\\\daawebsite\\\\src\\\\pages\\\\algorithms\\\\Algorithm3.js\";\n// src/pages/Algorithm3.js\nimport React from 'react';\nimport CodeEditor from '../../components/CodeEditor';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Algorithm3 = () => {\n  const codeSnippet = `#include <iostream>\n#include <fstream>\n#include <unordered_set>\n#include <vector>\n#include <climits>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nclass MaximalCliques {\nprivate:\n    vector<unordered_set<int>> graph;\n    unordered_set<int> Q;\n    int maxCliqueSize = 0;\n    int totalCliques = 0;\n    unordered_map<int, int> cliqueDistribution;\n\npublic:\n    MaximalCliques(vector<unordered_set<int>> g) : graph(std::move(g)) {}\n\n    void printClique() {\n        cout << \"Clique: \";\n        for (int v : Q) cout << v << \" \";\n        cout << \"\\\\n\";\n    }\n\n    void expand(unordered_set<int>& SUBG, unordered_set<int>& CAND) {\n        if (SUBG.empty()) {\n            int cliqueSize = (int)Q.size();\n            maxCliqueSize = max(maxCliqueSize, cliqueSize);\n            totalCliques++;\n            cout << totalCliques << \"\\\\n\";\n            cliqueDistribution[cliqueSize]++;\n            return;\n        }\n\n        int u = *SUBG.begin();\n        for (int v : SUBG)\n            if (CAND.size() > graph[u].size()) u = v;\n\n        unordered_set<int> EXT;\n        for (int v : CAND)\n            if (!graph[u].count(v)) EXT.insert(v);\n\n        for (auto it = EXT.begin(); it != EXT.end();) {\n            int q = *it;\n            it = EXT.erase(it);\n\n            Q.insert(q);\n\n            unordered_set<int> newSUBG, newCAND;\n            for (int v : SUBG)\n                if (graph[q].count(v)) newSUBG.insert(v);\n            for (int v : CAND)\n                if (graph[q].count(v)) newCAND.insert(v);\n\n            expand(newSUBG, newCAND);\n            CAND.erase(q);\n            Q.erase(q);\n        }\n    }\n\n    void findCliques() {\n        unordered_set<int> SUBG, CAND;\n        for (int i = 0; i < graph.size(); i++)\n            SUBG.insert(i), CAND.insert(i);\n        \n        expand(SUBG, CAND);\n\n        cout << \"\\\\nLargest Clique Size: \" << maxCliqueSize << \"\\\\n\";\n        cout << \"Total Maximal Cliques: \" << totalCliques << \"\\\\n\";\n        vector<pair<int, int>> sortedDistribution(cliqueDistribution.begin(), cliqueDistribution.end());\n        sort(sortedDistribution.begin(), sortedDistribution.end());\n\n        cout << \"\\\\nClique Size Distribution:\\\\n\";\n        for (const auto& [size, count] : sortedDistribution) {\n            cout << \"Size \" << size << \": \" << count << \" cliques\\\\n\";\n        }\n    }\n};\n\nint main() {\n    int datasetId;\n    cout << \"Please select the dataset you want to use:\" << endl;\n    cout << \"1. Wiki-Vote\" << endl;\n    cout << \"2. Email-Enron\" << endl;\n    cout << \"3. Skitter\" << endl;\n\n    cin >> datasetId;\n\n    string filename;\n\n    switch (datasetId) {\n        case 1:\n            cout << \"Loading Wiki-Vote dataset...\" << endl;\n            filename = \"Dataset/Wiki-Vote.txt\";\n            break;\n        case 2:\n            cout << \"Loading Email-Enron dataset...\" << endl;\n            filename = \"Dataset/Email-Enron.txt\";\n            break;\n        case 3:\n            cout << \"Loading Skitter dataset...\" << endl;\n            filename = \"Dataset/as-skitter.txt\";\n            break;\n        default:\n            cout << \"Invalid dataset selection\" << endl;\n            return 1;\n    }\n\n    ifstream file(filename);\n    if (!file.is_open()) {\n        cout << \"Error opening file: \" << filename << endl;\n        return 1;\n    }\n\n    int numNodes, numEdges;\n    file >> numNodes >> numEdges;\n    \n    unordered_map<int, int> nodeId, reverseNodeId;\n    vector<unordered_set<int>> graph(numNodes);\n    int u, v, id = 0;\n\n    while (file >> u >> v) {\n        if (nodeId.find(u) == nodeId.end()) {\n            nodeId[u] = id;\n            reverseNodeId[id] = u;\n            id++;\n        }\n        if (nodeId.find(v) == nodeId.end()) {\n            nodeId[v] = id;\n            reverseNodeId[id] = v;\n            id++;\n        }\n        graph[nodeId[u]].insert(nodeId[v]);\n        graph[nodeId[v]].insert(nodeId[u]);\n    }\n    file.close();\n\n    MaximalCliques solver(std::move(graph));\n    clock_t start = clock();\n    solver.findCliques();\n    clock_t end = clock();\n    double elapsed = double(end - start) / CLOCKS_PER_SEC;\n    cout << \"Time: \" << elapsed << \"s\" << \"\\\\n\";\n\n    return 0;\n}`;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      padding: '1rem'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Algorithm 3\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Overview\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 164,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"This project implements and evaluates the Clique Listing Algorithm based on arboricity, as proposed by Chiba and Nishizeki. The algorithm efficiently lists all maximal cliques in a graph with a worst-case time complexity of O(a(G) * m) per clique, where a(G) is the arboricity of the graph and m is the number of edges.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 165,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 163,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Implementation Details\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 171,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Graph Representation:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 173,\n            columnNumber: 13\n          }, this), \" Use adjacency lists for efficient traversal.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 173,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Vertex Ordering\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 174,\n            columnNumber: 13\n          }, this), \" Sort vertices in non-decreasing degree order to optimize traversal.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 174,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Recursive Clique Listing:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 175,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n            children: [/*#__PURE__*/_jsxDEV(\"li\", {\n              children: \"Process vertices one by one.\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 177,\n              columnNumber: 13\n            }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n              children: \"Expand cliques efficiently while ensuring no duplication.\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 178,\n              columnNumber: 13\n            }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n              children: \"Use lexicographic filtering to avoid redundant clique generation.\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 179,\n              columnNumber: 13\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 176,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 175,\n          columnNumber: 9\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 172,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Code\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 183,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(CodeEditor, {\n        code: codeSnippet\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 184,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 170,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Expectation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 188,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: \"Validation of O(a(G) * m) complexity on real-world networks.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 189,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 187,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Observation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 195,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Tests indicate that the caching mechanism and memory optimizations significantly lower the space complexity, especially on large graphs.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 196,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 194,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 160,\n    columnNumber: 5\n  }, this);\n};\n_c = Algorithm3;\nexport default Algorithm3;\nvar _c;\n$RefreshReg$(_c, \"Algorithm3\");","map":{"version":3,"names":["React","CodeEditor","jsxDEV","_jsxDEV","Algorithm3","codeSnippet","style","padding","children","fileName","_jsxFileName","lineNumber","columnNumber","code","_c","$RefreshReg$"],"sources":["C:/Users/User/OneDrive/Acads 3-2/DAA/Project/daawebsite/src/pages/algorithms/Algorithm3.js"],"sourcesContent":["// src/pages/Algorithm3.js\r\nimport React from 'react';\r\nimport CodeEditor from '../../components/CodeEditor';\r\n\r\n\r\nconst Algorithm3 = () => {\r\n  const codeSnippet = `#include <iostream>\r\n#include <fstream>\r\n#include <unordered_set>\r\n#include <vector>\r\n#include <climits>\r\n#include <map>\r\n#include <unordered_map>\r\n#include <set>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nclass MaximalCliques {\r\nprivate:\r\n    vector<unordered_set<int>> graph;\r\n    unordered_set<int> Q;\r\n    int maxCliqueSize = 0;\r\n    int totalCliques = 0;\r\n    unordered_map<int, int> cliqueDistribution;\r\n\r\npublic:\r\n    MaximalCliques(vector<unordered_set<int>> g) : graph(std::move(g)) {}\r\n\r\n    void printClique() {\r\n        cout << \"Clique: \";\r\n        for (int v : Q) cout << v << \" \";\r\n        cout << \"\\\\n\";\r\n    }\r\n\r\n    void expand(unordered_set<int>& SUBG, unordered_set<int>& CAND) {\r\n        if (SUBG.empty()) {\r\n            int cliqueSize = (int)Q.size();\r\n            maxCliqueSize = max(maxCliqueSize, cliqueSize);\r\n            totalCliques++;\r\n            cout << totalCliques << \"\\\\n\";\r\n            cliqueDistribution[cliqueSize]++;\r\n            return;\r\n        }\r\n\r\n        int u = *SUBG.begin();\r\n        for (int v : SUBG)\r\n            if (CAND.size() > graph[u].size()) u = v;\r\n\r\n        unordered_set<int> EXT;\r\n        for (int v : CAND)\r\n            if (!graph[u].count(v)) EXT.insert(v);\r\n\r\n        for (auto it = EXT.begin(); it != EXT.end();) {\r\n            int q = *it;\r\n            it = EXT.erase(it);\r\n\r\n            Q.insert(q);\r\n\r\n            unordered_set<int> newSUBG, newCAND;\r\n            for (int v : SUBG)\r\n                if (graph[q].count(v)) newSUBG.insert(v);\r\n            for (int v : CAND)\r\n                if (graph[q].count(v)) newCAND.insert(v);\r\n\r\n            expand(newSUBG, newCAND);\r\n            CAND.erase(q);\r\n            Q.erase(q);\r\n        }\r\n    }\r\n\r\n    void findCliques() {\r\n        unordered_set<int> SUBG, CAND;\r\n        for (int i = 0; i < graph.size(); i++)\r\n            SUBG.insert(i), CAND.insert(i);\r\n        \r\n        expand(SUBG, CAND);\r\n\r\n        cout << \"\\\\nLargest Clique Size: \" << maxCliqueSize << \"\\\\n\";\r\n        cout << \"Total Maximal Cliques: \" << totalCliques << \"\\\\n\";\r\n        vector<pair<int, int>> sortedDistribution(cliqueDistribution.begin(), cliqueDistribution.end());\r\n        sort(sortedDistribution.begin(), sortedDistribution.end());\r\n\r\n        cout << \"\\\\nClique Size Distribution:\\\\n\";\r\n        for (const auto& [size, count] : sortedDistribution) {\r\n            cout << \"Size \" << size << \": \" << count << \" cliques\\\\n\";\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    int datasetId;\r\n    cout << \"Please select the dataset you want to use:\" << endl;\r\n    cout << \"1. Wiki-Vote\" << endl;\r\n    cout << \"2. Email-Enron\" << endl;\r\n    cout << \"3. Skitter\" << endl;\r\n\r\n    cin >> datasetId;\r\n\r\n    string filename;\r\n\r\n    switch (datasetId) {\r\n        case 1:\r\n            cout << \"Loading Wiki-Vote dataset...\" << endl;\r\n            filename = \"Dataset/Wiki-Vote.txt\";\r\n            break;\r\n        case 2:\r\n            cout << \"Loading Email-Enron dataset...\" << endl;\r\n            filename = \"Dataset/Email-Enron.txt\";\r\n            break;\r\n        case 3:\r\n            cout << \"Loading Skitter dataset...\" << endl;\r\n            filename = \"Dataset/as-skitter.txt\";\r\n            break;\r\n        default:\r\n            cout << \"Invalid dataset selection\" << endl;\r\n            return 1;\r\n    }\r\n\r\n    ifstream file(filename);\r\n    if (!file.is_open()) {\r\n        cout << \"Error opening file: \" << filename << endl;\r\n        return 1;\r\n    }\r\n\r\n    int numNodes, numEdges;\r\n    file >> numNodes >> numEdges;\r\n    \r\n    unordered_map<int, int> nodeId, reverseNodeId;\r\n    vector<unordered_set<int>> graph(numNodes);\r\n    int u, v, id = 0;\r\n\r\n    while (file >> u >> v) {\r\n        if (nodeId.find(u) == nodeId.end()) {\r\n            nodeId[u] = id;\r\n            reverseNodeId[id] = u;\r\n            id++;\r\n        }\r\n        if (nodeId.find(v) == nodeId.end()) {\r\n            nodeId[v] = id;\r\n            reverseNodeId[id] = v;\r\n            id++;\r\n        }\r\n        graph[nodeId[u]].insert(nodeId[v]);\r\n        graph[nodeId[v]].insert(nodeId[u]);\r\n    }\r\n    file.close();\r\n\r\n    MaximalCliques solver(std::move(graph));\r\n    clock_t start = clock();\r\n    solver.findCliques();\r\n    clock_t end = clock();\r\n    double elapsed = double(end - start) / CLOCKS_PER_SEC;\r\n    cout << \"Time: \" << elapsed << \"s\" << \"\\\\n\";\r\n\r\n    return 0;\r\n}`;\r\n\r\n  return (\r\n    <div style={{ padding: '1rem' }}>\r\n      <h1>Algorithm 3</h1>\r\n      \r\n      <section>\r\n        <h2>Overview</h2>\r\n        <p>\r\n        This project implements and evaluates the Clique Listing Algorithm based on arboricity, as proposed by Chiba and Nishizeki. The algorithm efficiently lists all maximal cliques in a graph with a worst-case time complexity of O(a(G) * m) per clique, where a(G) is the arboricity of the graph and m is the number of edges.\r\n        </p>\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>Implementation Details</h2>\r\n        <ul>\r\n        <li><strong>Graph Representation:</strong> Use adjacency lists for efficient traversal.</li>\r\n        <li><strong>Vertex Ordering</strong> Sort vertices in non-decreasing degree order to optimize traversal.</li>\r\n        <li><strong>Recursive Clique Listing:</strong>\r\n            <ul>\r\n            <li>Process vertices one by one.</li>\r\n            <li>Expand cliques efficiently while ensuring no duplication.</li>\r\n            <li>Use lexicographic filtering to avoid redundant clique generation.</li>\r\n            </ul>\r\n        </li>\r\n        </ul>\r\n        <h3>Code</h3>\r\n        <CodeEditor code={codeSnippet} />\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>Expectation</h2>\r\n        <ul>\r\n            Validation of O(a(G) * m) complexity on real-world networks.\r\n        </ul>\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>Observation</h2>\r\n        <p>\r\n          Tests indicate that the caching mechanism and memory optimizations significantly lower the space complexity, especially on large graphs.\r\n        </p>\r\n      </section>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Algorithm3;\r\n"],"mappings":";AAAA;AACA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,UAAU,MAAM,6BAA6B;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAGrD,MAAMC,UAAU,GAAGA,CAAA,KAAM;EACvB,MAAMC,WAAW,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;EAEA,oBACEF,OAAA;IAAKG,KAAK,EAAE;MAAEC,OAAO,EAAE;IAAO,CAAE;IAAAC,QAAA,gBAC9BL,OAAA;MAAAK,QAAA,EAAI;IAAW;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAI,CAAC,eAEpBT,OAAA;MAAAK,QAAA,gBACEL,OAAA;QAAAK,QAAA,EAAI;MAAQ;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAI,CAAC,eACjBT,OAAA;QAAAK,QAAA,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}