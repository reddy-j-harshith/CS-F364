{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\User\\\\OneDrive\\\\Acads 3-2\\\\DAA\\\\Project\\\\daawebsite\\\\src\\\\pages\\\\algorithms\\\\Algorithm1.js\";\n// src/pages/Algorithm1.js\nimport React from 'react';\nimport CodeEditor from '../../components/CodeEditor';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Algorithm1 = () => {\n  const codeSnippet = `#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <unordered_map>\n#include <list>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <limits>\n#include <chrono>\n#include <cassert>\n\nusing namespace std;\nusing namespace std::chrono;\n\n// ----- Graph I/O and Conversion Functions -----\n\nbool isDirected(const unordered_map<int, list<int>>& adj) {\n    for (const auto& pair : adj) {\n        int u = pair.first;\n        for (int v : pair.second) {\n            auto it = adj.find(v);\n            if (it == adj.end() || find(it->second.begin(), it->second.end(), u) == it->second.end())\n                return true;\n        }\n    }\n    return false;\n}\n\nvoid convertToUndirected(unordered_map<int, list<int>>& adj) {\n    for (auto& pair : adj) {\n        int u = pair.first;\n        for (int v : pair.second) {\n            auto it = adj.find(v);\n            if (it != adj.end()) {\n                if (find(it->second.begin(), it->second.end(), u) == it->second.end())\n                    it->second.push_back(u);\n            } else {\n                adj[v] = list<int>{u};\n            }\n        }\n    }\n}\n\n// ----- Global Data Structures for Clique Enumeration -----\n\nvector<int> S;  // temporary array (unused placeholder)\nvector<int> T;  // temporary array (unused placeholder)\nstack<int> C;   // global stack for current clique\n\n// Global statistics\nint maxCliqueSize = 0;          // Largest clique size encountered\nint totalMaximalCliques = 0;    // Total number of maximal cliques found\nvector<int> cliqueSizeDistribution; // Distribution: index i -> count of maximal cliques of size i\n\n// ----- Helper Functions for Maximality and Lexicographic Tests -----\n//\n// These implementations mimic the conditions in Lemmas 4–6 of the paper.\n// They assume vertices are numbered in nondecreasing order of degree.\n\n// Maximality test: Check that no vertex y (with y < candidate) outside the current clique\n// is adjacent to every vertex in the clique.\nbool checkMaximality(const stack<int>& cliqueStack, const vector<vector<int>>& neighborList, int candidate) {\n    // Extract current clique from the stack into a vector.\n    vector<int> clique;\n    {\n        stack<int> temp = cliqueStack;\n        while (!temp.empty()) {\n            clique.push_back(temp.top());\n            temp.pop();\n        }\n        reverse(clique.begin(), clique.end());\n    }\n    int numVertices = neighborList.size();\n    vector<bool> inClique(numVertices, false);\n    for (int v : clique)\n        inClique[v] = true;\n\n    // For each neighbor y of candidate that is not in the clique, consider only y with y < candidate.\n    for (int y : neighborList[candidate]) {\n        if (inClique[y])\n            continue; // already in clique\n        if (y >= candidate)\n            continue;\n        // Check whether y is adjacent to every vertex in the current clique.\n        bool adjacentToAll = true;\n        for (int v : clique) {\n            if (!binary_search(neighborList[v].begin(), neighborList[v].end(), y)) {\n                adjacentToAll = false;\n                break;\n            }\n        }\n        if (adjacentToAll)\n            return false; // Found a vertex y that could extend the clique.\n    }\n    return true;\n}\n\n// Lexicographic test: Ensure that no vertex j (with j < candidate) exists such that j is adjacent\n// to every vertex in the current clique and to candidate. This helps avoid duplicate clique outputs.\nbool checkLexico(const stack<int>& cliqueStack, const vector<vector<int>>& neighborList, int candidate) {\n    // Extract current clique from the stack into a vector.\n    vector<int> clique;\n    {\n        stack<int> temp = cliqueStack;\n        while (!temp.empty()) {\n            clique.push_back(temp.top());\n            temp.pop();\n        }\n        reverse(clique.begin(), clique.end());\n    }\n    int numVertices = neighborList.size();\n    vector<bool> inClique(numVertices, false);\n    for (int v : clique)\n        inClique[v] = true;\n\n    // For every vertex j with index less than candidate and not in the clique:\n    for (int j = 0; j < candidate; j++) {\n        if (inClique[j])\n            continue;\n        // Candidate must be adjacent to j.\n        if (!binary_search(neighborList[candidate].begin(), neighborList[candidate].end(), j))\n            continue;\n        bool adjacentToAll = true;\n        for (int v : clique) {\n            if (!binary_search(neighborList[v].begin(), neighborList[v].end(), j)) {\n                adjacentToAll = false;\n                break;\n            }\n        }\n        if (adjacentToAll)\n            return false; // There exists a vertex j < candidate that could have been added.\n    }\n    return true;\n}\n\n// ----- Helper Function: Check if the current clique is maximal -----\n//\n// A clique is maximal if no vertex outside the clique is adjacent to all vertices in the clique.\nbool isMaximalClique(const stack<int>& cliqueStack, const vector<vector<int>>& neighborList, int numVertices) {\n    vector<int> clique;\n    {\n        stack<int> temp = cliqueStack;\n        while (!temp.empty()) {\n            clique.push_back(temp.top());\n            temp.pop();\n        }\n    }\n    reverse(clique.begin(), clique.end());\n\n    vector<bool> inClique(numVertices, false);\n    for (int v : clique)\n        inClique[v] = true;\n\n    for (int v = 0; v < numVertices; v++) {\n        if (!inClique[v]) {\n            bool adjacentToAll = true;\n            for (int u : clique) {\n                if (!binary_search(neighborList[u].begin(), neighborList[u].end(), v)) {\n                    adjacentToAll = false;\n                    break;\n                }\n            }\n            if (adjacentToAll)\n                return false; // Found a vertex that can extend the clique.\n        }\n    }\n    return true;\n}\n\n// ----- Clique Output Function -----\nvoid outputClique(const stack<int>& cliqueStack) {\n    vector<int> clique;\n    {\n        stack<int> temp = cliqueStack;\n        while (!temp.empty()) {\n            clique.push_back(temp.top());\n            temp.pop();\n        }\n    }\n    reverse(clique.begin(), clique.end());\n    \n    int cliqueSize = clique.size();\n    maxCliqueSize = max(maxCliqueSize, cliqueSize);\n    totalMaximalCliques++;\n    cout << \"\\\\nClique #\" << totalMaximalCliques << \": \";\n    for (int v : clique)\n        cout << v << \" \";\n    cout << endl;\n    \n    if (cliqueSize >= (int)cliqueSizeDistribution.size())\n        cliqueSizeDistribution.resize(cliqueSize + 1, 0);\n    cliqueSizeDistribution[cliqueSize]++;\n}\n\n// ----- Vertex Deletion Function -----\n//\n// Deletes vertex 'v' from the graph represented by neighborList by removing it from all neighbor lists.\nvoid deleteVertex(int v, vector<vector<int>>& neighborList) {\n    int n = neighborList.size();\n    for (int i = 0; i < n; i++) {\n        auto& nbrs = neighborList[i];\n        nbrs.erase(remove(nbrs.begin(), nbrs.end(), v), nbrs.end());\n    }\n    // Clear the neighbor list for vertex v to mark it as deleted.\n    neighborList[v].clear();\n}\n\n// ----- Recursive UPDATE Procedure -----\n// neighborList: for each vertex, its sorted list of neighbors (modifiable for vertex deletion)\n// numVertices: total number of vertices\n// i: current candidate vertex index\n// cliqueStack: current clique (passed by reference)\nvoid UPDATE(int i, vector<vector<int>>& neighborList, int numVertices, stack<int>& cliqueStack) {\n    // Base case: if we've considered all vertices, check if the current clique is maximal.\n    if (i >= numVertices) {\n        if (!cliqueStack.empty() && isMaximalClique(cliqueStack, neighborList, numVertices))\n            outputClique(cliqueStack);\n        return;\n    }\n    \n    // Save the current state of the neighborList for backtracking.\n    vector<vector<int>> backupNeighborList = neighborList;\n    \n    // Check if candidate i is adjacent to every vertex already in the clique.\n    bool canExtend = true;\n    {\n        stack<int> temp = cliqueStack;\n        while (!temp.empty()) {\n            int v = temp.top();\n            temp.pop();\n            if (!binary_search(neighborList[v].begin(), neighborList[v].end(), i)) {\n                canExtend = false;\n                break;\n            }\n        }\n    }\n    \n    // Branch: Include candidate i if it can extend the clique.\n    if (canExtend) {\n        if (checkMaximality(cliqueStack, neighborList, i) &&\n            checkLexico(cliqueStack, neighborList, i)) {\n            cliqueStack.push(i);\n            UPDATE(i + 1, neighborList, numVertices, cliqueStack);\n            cliqueStack.pop();  // backtrack\n        }\n    }\n    \n    // Branch: Exclude candidate i.\n    UPDATE(i + 1, neighborList, numVertices, cliqueStack);\n    \n    // Now perform the vertex deletion for candidate i.\n    deleteVertex(i, neighborList);\n    \n    // Restore neighborList for backtracking (so that sibling recursive calls use the original state).\n    neighborList = backupNeighborList;\n}\n\n// ----- Main Function -----\nint main() {\n    auto startTime = high_resolution_clock::now();\n    \n    bool fileIsDirected = false;  // Adjust if needed.\n    \n    int datasetId;\n    cout << \"Please select the dataset you want to use:\" << endl;\n    cout << \"1. Wiki-Vote\" << endl;\n    cout << \"2. Email-Enron\" << endl;\n    cout << \"3. Skitter\" << endl;\n\n    cin >> datasetId;\n\n    string filename;\n\n    switch (datasetId) {\n        case 1:\n            cout << \"Loading Wiki-Vote dataset...\" << endl;\n            filename = \"Dataset/Wiki-Vote.txt\";\n            break;\n        case 2:\n            cout << \"Loading Email-Enron dataset...\" << endl;\n            filename = \"Dataset/Email-Enron.txt\";\n            break;\n        case 3:\n            cout << \"Loading Skitter dataset...\" << endl;\n            filename = \"Dataset/as-skitter.txt\";\n            break;\n        default:\n            cout << \"Invalid dataset selection\" << endl;\n            return 1;\n    }\n\n    ifstream infile(filename);\n    if (!infile) {\n        cerr << \"Error: Could not open the file 'datasets/graph.txt'\" << endl;\n        return 1;\n    }\n    \n    string line;\n    int numVertices, numEdges;\n    if (getline(infile, line)) {\n        istringstream iss(line);\n        if (!(iss >> numVertices >> numEdges)) {\n            cerr << \"Error: First line must contain two integers.\" << endl;\n            return 1;\n        }\n    } else {\n        cerr << \"Error: File is empty or improperly formatted.\" << endl;\n        return 1;\n    }\n    \n    vector<pair<int, int>> edges;\n    while (getline(infile, line)) {\n        if (line.empty()) continue;\n        istringstream iss(line);\n        int from, to;\n        if (!(iss >> from >> to)) {\n            cerr << \"Error reading edge: \" << line << endl;\n            continue;\n        }\n        edges.push_back({from, to});\n    }\n    infile.close();\n    \n    int minVertex = numeric_limits<int>::max();\n    for (const auto& edge : edges)\n        minVertex = min({minVertex, edge.first, edge.second});\n    bool needConversion = (minVertex >= 1);\n    \n    unordered_map<int, list<int>> adj;\n    for (int i = 0; i < numVertices; i++)\n        adj[i] = list<int>();\n    \n    for (const auto& edge : edges) {\n        int u = edge.first, v = edge.second;\n        if (needConversion) {\n            u--; v--;\n        }\n        adj[u].push_back(v);\n        if (!fileIsDirected) {\n            if (find(adj[v].begin(), adj[v].end(), u) == adj[v].end())\n                adj[v].push_back(u);\n        }\n    }\n    \n    if (fileIsDirected) {\n        if (isDirected(adj)) {\n            cout << \"The graph is directed. Converting to undirected graph by adding missing reverse edges.\" << endl;\n            convertToUndirected(adj);\n        } else {\n            cout << \"The graph is already undirected.\" << endl;\n        }\n    } else {\n        cout << \"The file represents an undirected graph.\" << endl;\n    }\n    \n    vector<pair<int, int>> degreeList;\n    for (int i = 0; i < numVertices; i++)\n        degreeList.push_back({(int)adj[i].size(), i});\n    sort(degreeList.begin(), degreeList.end());\n    \n    cout << \"\\\\nVertices sorted in nondecreasing order of degree:\" << endl;\n    for (const auto& p : degreeList)\n        cout << \"Vertex \" << p.second << \" with degree \" << p.first << endl;\n    \n    vector<vector<int>> neighborList(numVertices);\n    for (int i = 0; i < numVertices; i++) {\n        for (int neighbor : adj[i])\n            neighborList[i].push_back(neighbor);\n        sort(neighborList[i].begin(), neighborList[i].end());\n    }\n    \n    // Prepare auxiliary arrays (currently unused but available for further refinement)\n    S.assign(numVertices, 0);\n    T.assign(numVertices, 0);\n    while (!C.empty())\n        C.pop();\n    \n    cout << \"\\\\nStarting clique enumeration (maximal cliques only)...\" << endl;\n    UPDATE(0, neighborList, numVertices, C);\n    \n    auto endTime = high_resolution_clock::now();\n    auto duration = duration_cast<milliseconds>(endTime - startTime).count();\n    \n    cout << \"\\\\n=== Clique Enumeration Statistics ===\" << endl;\n    cout << \"Largest clique size found: \" << maxCliqueSize << endl;\n    cout << \"Total number of maximal cliques: \" << totalMaximalCliques << endl;\n    cout << \"Execution time: \" << duration << \" ms\" << endl;\n    \n    cout << \"\\\\nClique Size Distribution:\" << endl;\n    for (size_t size = 1; size < cliqueSizeDistribution.size(); size++) {\n        if (cliqueSizeDistribution[size] > 0)\n            cout << \"Size \" << size << \": \" << cliqueSizeDistribution[size] << \" clique(s)\" << endl;\n    }\n    \n    return 0;\n}`;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      padding: '1rem'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Algorithm 1\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 407,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Overview\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 410,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"This project implements the maximal clique enumeration algorithm proposed by Tomita, Tanaka, and Takahashi, which is designed to generate all maximal cliques in an undirected graph. The algorithm builds on the depth-first search (DFS) approach used in the Bron\\u2013Kerbosch algorithm but introduces pruning techniques to improve efficiency. A key contribution of the paper is proving that the worst-case time complexity of the algorithm is O(3\\u207F/\\xB3), which is optimal for an n-vertex graph. Additionally, the algorithm outputs maximal cliques in a tree-like format, reducing memory consumption compared to traditional methods\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 411,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 409,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Implementation Details\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 417,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Graph Representation:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 419,\n            columnNumber: 15\n          }, this), \" Adjacency lists are used to represent the graph.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 419,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"DFS Approach:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 420,\n            columnNumber: 15\n          }, this), \" A recursive depth-first search is used with optimizations.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 420,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Pruning Strategies:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 421,\n            columnNumber: 15\n          }, this), \" Specific pivot selection to minimize recursive depth.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 421,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 418,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Code\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 423,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(CodeEditor, {\n        code: codeSnippet\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 424,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 416,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Expectation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 428,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Validate the O(3\\u207F/\\xB3) complexity with empirical results specific to Algorithm 1.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 430,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Show improved performance over standard approaches.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 431,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 429,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 427,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Observation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 436,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Initial tests indicate that the pivot strategy reduces redundant recursive calls, yielding better performance on sparse graphs.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 437,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 435,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 406,\n    columnNumber: 5\n  }, this);\n};\n_c = Algorithm1;\nexport default Algorithm1;\nvar _c;\n$RefreshReg$(_c, \"Algorithm1\");","map":{"version":3,"names":["React","CodeEditor","jsxDEV","_jsxDEV","Algorithm1","codeSnippet","style","padding","children","fileName","_jsxFileName","lineNumber","columnNumber","code","_c","$RefreshReg$"],"sources":["C:/Users/User/OneDrive/Acads 3-2/DAA/Project/daawebsite/src/pages/algorithms/Algorithm1.js"],"sourcesContent":["// src/pages/Algorithm1.js\r\nimport React from 'react';\r\nimport CodeEditor from '../../components/CodeEditor';\r\n\r\n\r\nconst Algorithm1 = () => {\r\n  const codeSnippet = `#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <unordered_map>\r\n#include <list>\r\n#include <vector>\r\n#include <stack>\r\n#include <algorithm>\r\n#include <limits>\r\n#include <chrono>\r\n#include <cassert>\r\n\r\nusing namespace std;\r\nusing namespace std::chrono;\r\n\r\n// ----- Graph I/O and Conversion Functions -----\r\n\r\nbool isDirected(const unordered_map<int, list<int>>& adj) {\r\n    for (const auto& pair : adj) {\r\n        int u = pair.first;\r\n        for (int v : pair.second) {\r\n            auto it = adj.find(v);\r\n            if (it == adj.end() || find(it->second.begin(), it->second.end(), u) == it->second.end())\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid convertToUndirected(unordered_map<int, list<int>>& adj) {\r\n    for (auto& pair : adj) {\r\n        int u = pair.first;\r\n        for (int v : pair.second) {\r\n            auto it = adj.find(v);\r\n            if (it != adj.end()) {\r\n                if (find(it->second.begin(), it->second.end(), u) == it->second.end())\r\n                    it->second.push_back(u);\r\n            } else {\r\n                adj[v] = list<int>{u};\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// ----- Global Data Structures for Clique Enumeration -----\r\n\r\nvector<int> S;  // temporary array (unused placeholder)\r\nvector<int> T;  // temporary array (unused placeholder)\r\nstack<int> C;   // global stack for current clique\r\n\r\n// Global statistics\r\nint maxCliqueSize = 0;          // Largest clique size encountered\r\nint totalMaximalCliques = 0;    // Total number of maximal cliques found\r\nvector<int> cliqueSizeDistribution; // Distribution: index i -> count of maximal cliques of size i\r\n\r\n// ----- Helper Functions for Maximality and Lexicographic Tests -----\r\n//\r\n// These implementations mimic the conditions in Lemmas 4–6 of the paper.\r\n// They assume vertices are numbered in nondecreasing order of degree.\r\n\r\n// Maximality test: Check that no vertex y (with y < candidate) outside the current clique\r\n// is adjacent to every vertex in the clique.\r\nbool checkMaximality(const stack<int>& cliqueStack, const vector<vector<int>>& neighborList, int candidate) {\r\n    // Extract current clique from the stack into a vector.\r\n    vector<int> clique;\r\n    {\r\n        stack<int> temp = cliqueStack;\r\n        while (!temp.empty()) {\r\n            clique.push_back(temp.top());\r\n            temp.pop();\r\n        }\r\n        reverse(clique.begin(), clique.end());\r\n    }\r\n    int numVertices = neighborList.size();\r\n    vector<bool> inClique(numVertices, false);\r\n    for (int v : clique)\r\n        inClique[v] = true;\r\n\r\n    // For each neighbor y of candidate that is not in the clique, consider only y with y < candidate.\r\n    for (int y : neighborList[candidate]) {\r\n        if (inClique[y])\r\n            continue; // already in clique\r\n        if (y >= candidate)\r\n            continue;\r\n        // Check whether y is adjacent to every vertex in the current clique.\r\n        bool adjacentToAll = true;\r\n        for (int v : clique) {\r\n            if (!binary_search(neighborList[v].begin(), neighborList[v].end(), y)) {\r\n                adjacentToAll = false;\r\n                break;\r\n            }\r\n        }\r\n        if (adjacentToAll)\r\n            return false; // Found a vertex y that could extend the clique.\r\n    }\r\n    return true;\r\n}\r\n\r\n// Lexicographic test: Ensure that no vertex j (with j < candidate) exists such that j is adjacent\r\n// to every vertex in the current clique and to candidate. This helps avoid duplicate clique outputs.\r\nbool checkLexico(const stack<int>& cliqueStack, const vector<vector<int>>& neighborList, int candidate) {\r\n    // Extract current clique from the stack into a vector.\r\n    vector<int> clique;\r\n    {\r\n        stack<int> temp = cliqueStack;\r\n        while (!temp.empty()) {\r\n            clique.push_back(temp.top());\r\n            temp.pop();\r\n        }\r\n        reverse(clique.begin(), clique.end());\r\n    }\r\n    int numVertices = neighborList.size();\r\n    vector<bool> inClique(numVertices, false);\r\n    for (int v : clique)\r\n        inClique[v] = true;\r\n\r\n    // For every vertex j with index less than candidate and not in the clique:\r\n    for (int j = 0; j < candidate; j++) {\r\n        if (inClique[j])\r\n            continue;\r\n        // Candidate must be adjacent to j.\r\n        if (!binary_search(neighborList[candidate].begin(), neighborList[candidate].end(), j))\r\n            continue;\r\n        bool adjacentToAll = true;\r\n        for (int v : clique) {\r\n            if (!binary_search(neighborList[v].begin(), neighborList[v].end(), j)) {\r\n                adjacentToAll = false;\r\n                break;\r\n            }\r\n        }\r\n        if (adjacentToAll)\r\n            return false; // There exists a vertex j < candidate that could have been added.\r\n    }\r\n    return true;\r\n}\r\n\r\n// ----- Helper Function: Check if the current clique is maximal -----\r\n//\r\n// A clique is maximal if no vertex outside the clique is adjacent to all vertices in the clique.\r\nbool isMaximalClique(const stack<int>& cliqueStack, const vector<vector<int>>& neighborList, int numVertices) {\r\n    vector<int> clique;\r\n    {\r\n        stack<int> temp = cliqueStack;\r\n        while (!temp.empty()) {\r\n            clique.push_back(temp.top());\r\n            temp.pop();\r\n        }\r\n    }\r\n    reverse(clique.begin(), clique.end());\r\n\r\n    vector<bool> inClique(numVertices, false);\r\n    for (int v : clique)\r\n        inClique[v] = true;\r\n\r\n    for (int v = 0; v < numVertices; v++) {\r\n        if (!inClique[v]) {\r\n            bool adjacentToAll = true;\r\n            for (int u : clique) {\r\n                if (!binary_search(neighborList[u].begin(), neighborList[u].end(), v)) {\r\n                    adjacentToAll = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (adjacentToAll)\r\n                return false; // Found a vertex that can extend the clique.\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// ----- Clique Output Function -----\r\nvoid outputClique(const stack<int>& cliqueStack) {\r\n    vector<int> clique;\r\n    {\r\n        stack<int> temp = cliqueStack;\r\n        while (!temp.empty()) {\r\n            clique.push_back(temp.top());\r\n            temp.pop();\r\n        }\r\n    }\r\n    reverse(clique.begin(), clique.end());\r\n    \r\n    int cliqueSize = clique.size();\r\n    maxCliqueSize = max(maxCliqueSize, cliqueSize);\r\n    totalMaximalCliques++;\r\n    cout << \"\\\\nClique #\" << totalMaximalCliques << \": \";\r\n    for (int v : clique)\r\n        cout << v << \" \";\r\n    cout << endl;\r\n    \r\n    if (cliqueSize >= (int)cliqueSizeDistribution.size())\r\n        cliqueSizeDistribution.resize(cliqueSize + 1, 0);\r\n    cliqueSizeDistribution[cliqueSize]++;\r\n}\r\n\r\n// ----- Vertex Deletion Function -----\r\n//\r\n// Deletes vertex 'v' from the graph represented by neighborList by removing it from all neighbor lists.\r\nvoid deleteVertex(int v, vector<vector<int>>& neighborList) {\r\n    int n = neighborList.size();\r\n    for (int i = 0; i < n; i++) {\r\n        auto& nbrs = neighborList[i];\r\n        nbrs.erase(remove(nbrs.begin(), nbrs.end(), v), nbrs.end());\r\n    }\r\n    // Clear the neighbor list for vertex v to mark it as deleted.\r\n    neighborList[v].clear();\r\n}\r\n\r\n// ----- Recursive UPDATE Procedure -----\r\n// neighborList: for each vertex, its sorted list of neighbors (modifiable for vertex deletion)\r\n// numVertices: total number of vertices\r\n// i: current candidate vertex index\r\n// cliqueStack: current clique (passed by reference)\r\nvoid UPDATE(int i, vector<vector<int>>& neighborList, int numVertices, stack<int>& cliqueStack) {\r\n    // Base case: if we've considered all vertices, check if the current clique is maximal.\r\n    if (i >= numVertices) {\r\n        if (!cliqueStack.empty() && isMaximalClique(cliqueStack, neighborList, numVertices))\r\n            outputClique(cliqueStack);\r\n        return;\r\n    }\r\n    \r\n    // Save the current state of the neighborList for backtracking.\r\n    vector<vector<int>> backupNeighborList = neighborList;\r\n    \r\n    // Check if candidate i is adjacent to every vertex already in the clique.\r\n    bool canExtend = true;\r\n    {\r\n        stack<int> temp = cliqueStack;\r\n        while (!temp.empty()) {\r\n            int v = temp.top();\r\n            temp.pop();\r\n            if (!binary_search(neighborList[v].begin(), neighborList[v].end(), i)) {\r\n                canExtend = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Branch: Include candidate i if it can extend the clique.\r\n    if (canExtend) {\r\n        if (checkMaximality(cliqueStack, neighborList, i) &&\r\n            checkLexico(cliqueStack, neighborList, i)) {\r\n            cliqueStack.push(i);\r\n            UPDATE(i + 1, neighborList, numVertices, cliqueStack);\r\n            cliqueStack.pop();  // backtrack\r\n        }\r\n    }\r\n    \r\n    // Branch: Exclude candidate i.\r\n    UPDATE(i + 1, neighborList, numVertices, cliqueStack);\r\n    \r\n    // Now perform the vertex deletion for candidate i.\r\n    deleteVertex(i, neighborList);\r\n    \r\n    // Restore neighborList for backtracking (so that sibling recursive calls use the original state).\r\n    neighborList = backupNeighborList;\r\n}\r\n\r\n// ----- Main Function -----\r\nint main() {\r\n    auto startTime = high_resolution_clock::now();\r\n    \r\n    bool fileIsDirected = false;  // Adjust if needed.\r\n    \r\n    int datasetId;\r\n    cout << \"Please select the dataset you want to use:\" << endl;\r\n    cout << \"1. Wiki-Vote\" << endl;\r\n    cout << \"2. Email-Enron\" << endl;\r\n    cout << \"3. Skitter\" << endl;\r\n\r\n    cin >> datasetId;\r\n\r\n    string filename;\r\n\r\n    switch (datasetId) {\r\n        case 1:\r\n            cout << \"Loading Wiki-Vote dataset...\" << endl;\r\n            filename = \"Dataset/Wiki-Vote.txt\";\r\n            break;\r\n        case 2:\r\n            cout << \"Loading Email-Enron dataset...\" << endl;\r\n            filename = \"Dataset/Email-Enron.txt\";\r\n            break;\r\n        case 3:\r\n            cout << \"Loading Skitter dataset...\" << endl;\r\n            filename = \"Dataset/as-skitter.txt\";\r\n            break;\r\n        default:\r\n            cout << \"Invalid dataset selection\" << endl;\r\n            return 1;\r\n    }\r\n\r\n    ifstream infile(filename);\r\n    if (!infile) {\r\n        cerr << \"Error: Could not open the file 'datasets/graph.txt'\" << endl;\r\n        return 1;\r\n    }\r\n    \r\n    string line;\r\n    int numVertices, numEdges;\r\n    if (getline(infile, line)) {\r\n        istringstream iss(line);\r\n        if (!(iss >> numVertices >> numEdges)) {\r\n            cerr << \"Error: First line must contain two integers.\" << endl;\r\n            return 1;\r\n        }\r\n    } else {\r\n        cerr << \"Error: File is empty or improperly formatted.\" << endl;\r\n        return 1;\r\n    }\r\n    \r\n    vector<pair<int, int>> edges;\r\n    while (getline(infile, line)) {\r\n        if (line.empty()) continue;\r\n        istringstream iss(line);\r\n        int from, to;\r\n        if (!(iss >> from >> to)) {\r\n            cerr << \"Error reading edge: \" << line << endl;\r\n            continue;\r\n        }\r\n        edges.push_back({from, to});\r\n    }\r\n    infile.close();\r\n    \r\n    int minVertex = numeric_limits<int>::max();\r\n    for (const auto& edge : edges)\r\n        minVertex = min({minVertex, edge.first, edge.second});\r\n    bool needConversion = (minVertex >= 1);\r\n    \r\n    unordered_map<int, list<int>> adj;\r\n    for (int i = 0; i < numVertices; i++)\r\n        adj[i] = list<int>();\r\n    \r\n    for (const auto& edge : edges) {\r\n        int u = edge.first, v = edge.second;\r\n        if (needConversion) {\r\n            u--; v--;\r\n        }\r\n        adj[u].push_back(v);\r\n        if (!fileIsDirected) {\r\n            if (find(adj[v].begin(), adj[v].end(), u) == adj[v].end())\r\n                adj[v].push_back(u);\r\n        }\r\n    }\r\n    \r\n    if (fileIsDirected) {\r\n        if (isDirected(adj)) {\r\n            cout << \"The graph is directed. Converting to undirected graph by adding missing reverse edges.\" << endl;\r\n            convertToUndirected(adj);\r\n        } else {\r\n            cout << \"The graph is already undirected.\" << endl;\r\n        }\r\n    } else {\r\n        cout << \"The file represents an undirected graph.\" << endl;\r\n    }\r\n    \r\n    vector<pair<int, int>> degreeList;\r\n    for (int i = 0; i < numVertices; i++)\r\n        degreeList.push_back({(int)adj[i].size(), i});\r\n    sort(degreeList.begin(), degreeList.end());\r\n    \r\n    cout << \"\\\\nVertices sorted in nondecreasing order of degree:\" << endl;\r\n    for (const auto& p : degreeList)\r\n        cout << \"Vertex \" << p.second << \" with degree \" << p.first << endl;\r\n    \r\n    vector<vector<int>> neighborList(numVertices);\r\n    for (int i = 0; i < numVertices; i++) {\r\n        for (int neighbor : adj[i])\r\n            neighborList[i].push_back(neighbor);\r\n        sort(neighborList[i].begin(), neighborList[i].end());\r\n    }\r\n    \r\n    // Prepare auxiliary arrays (currently unused but available for further refinement)\r\n    S.assign(numVertices, 0);\r\n    T.assign(numVertices, 0);\r\n    while (!C.empty())\r\n        C.pop();\r\n    \r\n    cout << \"\\\\nStarting clique enumeration (maximal cliques only)...\" << endl;\r\n    UPDATE(0, neighborList, numVertices, C);\r\n    \r\n    auto endTime = high_resolution_clock::now();\r\n    auto duration = duration_cast<milliseconds>(endTime - startTime).count();\r\n    \r\n    cout << \"\\\\n=== Clique Enumeration Statistics ===\" << endl;\r\n    cout << \"Largest clique size found: \" << maxCliqueSize << endl;\r\n    cout << \"Total number of maximal cliques: \" << totalMaximalCliques << endl;\r\n    cout << \"Execution time: \" << duration << \" ms\" << endl;\r\n    \r\n    cout << \"\\\\nClique Size Distribution:\" << endl;\r\n    for (size_t size = 1; size < cliqueSizeDistribution.size(); size++) {\r\n        if (cliqueSizeDistribution[size] > 0)\r\n            cout << \"Size \" << size << \": \" << cliqueSizeDistribution[size] << \" clique(s)\" << endl;\r\n    }\r\n    \r\n    return 0;\r\n}`;\r\n\r\n  return (\r\n    <div style={{ padding: '1rem' }}>\r\n      <h1>Algorithm 1</h1>\r\n      \r\n      <section>\r\n        <h2>Overview</h2>\r\n        <p>\r\n        This project implements the maximal clique enumeration algorithm proposed by Tomita, Tanaka, and Takahashi, which is designed to generate all maximal cliques in an undirected graph. The algorithm builds on the depth-first search (DFS) approach used in the Bron–Kerbosch algorithm but introduces pruning techniques to improve efficiency. A key contribution of the paper is proving that the worst-case time complexity of the algorithm is O(3ⁿ/³), which is optimal for an n-vertex graph. Additionally, the algorithm outputs maximal cliques in a tree-like format, reducing memory consumption compared to traditional methods\r\n        </p>\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>Implementation Details</h2>\r\n        <ul>\r\n          <li><strong>Graph Representation:</strong> Adjacency lists are used to represent the graph.</li>\r\n          <li><strong>DFS Approach:</strong> A recursive depth-first search is used with optimizations.</li>\r\n          <li><strong>Pruning Strategies:</strong> Specific pivot selection to minimize recursive depth.</li>\r\n        </ul>\r\n        <h3>Code</h3>\r\n        <CodeEditor code={codeSnippet} />\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>Expectation</h2>\r\n        <ul>\r\n          <li>Validate the O(3ⁿ/³) complexity with empirical results specific to Algorithm 1.</li>\r\n          <li>Show improved performance over standard approaches.</li>\r\n        </ul>\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>Observation</h2>\r\n        <p>\r\n          Initial tests indicate that the pivot strategy reduces redundant recursive calls, yielding better performance on sparse graphs.\r\n        </p>\r\n      </section>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Algorithm1;\r\n"],"mappings":";AAAA;AACA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,UAAU,MAAM,6BAA6B;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAGrD,MAAMC,UAAU,GAAGA,CAAA,KAAM;EACvB,MAAMC,WAAW,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;EAEA,oBACEF,OAAA;IAAKG,KAAK,EAAE;MAAEC,OAAO,EAAE;IAAO,CAAE;IAAAC,QAAA,gBAC9BL,OAAA;MAAAK,QAAA,EAAI;IAAW;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAI,CAAC,eAEpBT,OAAA;MAAAK,QAAA,gBACEL,OAAA;QAAAK,QAAA,EAAI;MAAQ;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}