{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\User\\\\OneDrive\\\\Acads 3-2\\\\DAA\\\\Project\\\\daawebsite\\\\src\\\\pages\\\\algorithms\\\\Algorithm2.js\";\n// src/pages/Algorithm2.js\nimport React from 'react';\nimport CodeEditor from '../../components/CodeEditor';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Algorithm2 = () => {\n  const codeSnippet = `#include<iostream>\n#include<set>\n#include<vector>\n#include<fstream>\n#include<algorithm>\n#include<unordered_map>\n#include<unordered_set>\n\nusing namespace std;\n\nclass MaximalCliques {\nprivate:\n    unordered_map<int, int> nodeId;\n    unordered_map<int, int> reverseNodeId;\n    vector<unordered_set<int>> graph;\n    vector<int> degenMap;\n    vector<int> degenOrder;\n\n    // Stats\n    int largestClique = 0;\n    long long int cliques = 0;\n    clock_t startTime, endTime;\n    double elapsedTime;\n    unordered_map<int, int> cliqueFreq;\n\npublic:\n    MaximalCliques(unordered_map<int, int>& nodeId, unordered_map<int, int>& reverseNodeId, vector<unordered_set<int>>& graph) \n        : nodeId(nodeId), reverseNodeId(reverseNodeId), graph(graph) {}\n\n    void degeneracyOrdering() {\n        int nodes = graph.size();\n        degenMap.resize(nodes);\n        vector<int> degree(nodes);\n        set<pair<int, int>> order;\n\n        for (int i = 0; i < nodes; i++) {\n            degree[i] = graph[i].size();\n            order.insert({degree[i], i});\n        }\n\n        int idx = 0;\n        while (!order.empty()) {\n            int v = order.begin()->second;\n            order.erase(order.begin());\n\n            degenOrder.push_back(v);\n            degenMap[v] = idx++;\n\n            for (int neighbor : graph[v]) {\n                if (order.count({degree[neighbor], neighbor})) {\n                    order.erase({degree[neighbor], neighbor});\n                    degree[neighbor]--;\n                    order.insert({degree[neighbor], neighbor});\n                }\n            }\n        }\n    }\n\n    int Tomita(const vector<int> &P, const vector<int> &X) {\n        int pivot = -1, maxCount = -1;\n\n        for (int u : P) {\n            int count = 0;\n            for (int v : P) {\n                if (graph[u].count(v)) count++;\n            }\n            if (count > maxCount) {\n                maxCount = count;\n                pivot = u;\n            }\n        }\n    \n        for (int u : X) {\n            int count = 0;\n            for (int v : P) {\n                if (graph[u].count(v)) count++;\n            }\n            if (count > maxCount) {\n                maxCount = count;\n                pivot = u;\n            }\n        }\n        return pivot;\n    }\n\n    void BronKerboschPivot(vector<int> &P, vector<int> &R, vector<int> &X) {\n        if (P.empty() && X.empty()) {\n            // Stat updates\n            int cliqueSize = (int)R.size();\n\n            largestClique = max(largestClique, cliqueSize);\n            cliques++;\n            cliqueFreq[cliqueSize]++;\n\n            cout << \"Maximal Clique Found: \" << cliques << \"\\n\";\n            return;\n        }\n\n        int u = Tomita(P, X);\n\n        vector<int> P_copy = P;\n        for (int v : P_copy) {\n            if (graph[u].find(v) == graph[u].end()) {\n                vector<int> P_new, X_new;\n                for (int w : P) {\n                    if (graph[v].find(w) != graph[v].end()) {\n                        P_new.push_back(w);\n                    }\n                }\n                for (int w : X) {\n                    if (graph[v].find(w) != graph[v].end()) {\n                        X_new.push_back(w);\n                    }\n                }\n\n                R.push_back(v);\n                BronKerboschPivot(P_new, R, X_new);\n                R.pop_back();\n\n                P.erase(find(P.begin(), P.end(), v));\n                X.push_back(v);\n            }\n        }\n    }\n\n    void BronKerboschDegeneracy() {\n        degeneracyOrdering();\n        for (int node : degenOrder) {\n            vector<int> P, X;\n            for (int neighbor : graph[node]) {\n                if (degenMap[neighbor] > degenMap[node]) {\n                    P.push_back(neighbor);\n                } else {\n                    X.push_back(neighbor);\n                }\n            }\n\n            vector<int> R = {node};\n            BronKerboschPivot(P, R, X);\n        }\n    }\n\n    void TimeAlgorithm() {\n        startTime = clock();\n        BronKerboschDegeneracy();\n        endTime = clock();\n        elapsedTime = double(endTime - startTime) / CLOCKS_PER_SEC;\n\n        cout << \"Total time taken: \" << elapsedTime << \" seconds\\n\";\n        cout << \"Largest clique size: \" << largestClique << \"\\n\";\n        cout << \"Total number of maximal cliques: \" << cliques << \"\\n\";\n        cout << \"Clique frequency distribution:\\n\";\n        for (const auto& entry : cliqueFreq) {\n            cout << \"Size \" << entry.first << \": \" << entry.second << \"\\n\";\n        }\n    }\n};\n\nint main() {\n    int datasetId;\n    cout << \"Please select the dataset you want to use:\" << endl;\n    cout << \"1. Wiki-Vote\" << endl;\n    cout << \"2. Email-Enron\" << endl;\n    cout << \"3. Skitter\" << endl;\n\n    cin >> datasetId;\n\n    string filename;\n\n    switch (datasetId) {\n        case 1:\n            cout << \"Loading Wiki-Vote dataset...\" << endl;\n            filename = \"Dataset/Wiki-Vote.txt\";\n            break;\n        case 2:\n            cout << \"Loading Email-Enron dataset...\" << endl;\n            filename = \"Dataset/Email-Enron.txt\";\n            break;\n        case 3:\n            cout << \"Loading Skitter dataset...\" << endl;\n            filename = \"Dataset/as-skitter.txt\";\n            break;\n        default:\n            cout << \"Invalid dataset selection\" << endl;\n            return 1;\n    }\n\n    ifstream file(filename);\n    if (!file.is_open()) {\n        cout << \"Error opening file: \" << filename << endl;\n        return 1;\n    }\n\n    int nodes, edges;\n    file >> nodes >> edges;\n\n    vector<unordered_set<int>> graph(nodes);\n    unordered_map<int, int> nodeId;\n    unordered_map<int, int> reverseNodeId;\n\n    int u, v, id = 0;\n    while (file >> u >> v) {\n        if (nodeId.find(u) == nodeId.end()) {\n            nodeId[u] = id;\n            reverseNodeId[id] = u;\n            id++;\n        }\n        if (nodeId.find(v) == nodeId.end()) {\n            nodeId[v] = id;\n            reverseNodeId[id] = v;\n            id++;\n        }\n\n        graph[nodeId[u]].insert(nodeId[v]);\n        graph[nodeId[v]].insert(nodeId[u]);\n    }\n\n    file.close();\n\n    MaximalCliques bk(nodeId, reverseNodeId, graph);\n    bk.TimeAlgorithm();\n\n    return 0;\n}`;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      padding: '1rem'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Algorithm 2\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 234,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Overview\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 237,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"This project focuses on implementing and analyzing a degeneracy-based variation of the Bron-Kerbosch algorithm for maximal clique enumeration in sparse graphs. The paper by Eppstein, L\\xF6ffler, and Strash introduces a novel approach that leverages graph degeneracy to improve performance in real-world networks, many of which are naturally sparse. By optimizing the recursive search strategy and reducing unnecessary computations, the algorithm achieves a worst-case time complexity of O(dn3d/3), which is nearly optimal for sparse graphs.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 238,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 236,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Implementation Details\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 244,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Graph Representation:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 246,\n            columnNumber: 13\n          }, this), \" Store the input as an adjacency list.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 246,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Enhanced DFS:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 247,\n            columnNumber: 13\n          }, this), \" Compute an ordering of vertices based on degeneracy.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 247,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Modified Bron-Kerbosch Algorithm:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 248,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n            children: [/*#__PURE__*/_jsxDEV(\"li\", {\n              children: \"Iterate over vertices in degeneracy order.\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 250,\n              columnNumber: 13\n            }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n              children: \"Use the pivoting strategy to reduce recursive calls.\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 251,\n              columnNumber: 13\n            }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n              children: \"Generate and report maximal cliques efficiently.\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 252,\n              columnNumber: 13\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 249,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 248,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Optimization:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 255,\n            columnNumber: 13\n          }, this), \" Use bitwise operations and data structures (hash maps, sets) for efficiency.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 255,\n          columnNumber: 9\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 245,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Code\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 258,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(CodeEditor, {\n        code: codeSnippet\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 259,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 243,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Expectation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 263,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Faster enumeration\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 265,\n            columnNumber: 15\n          }, this), \" in sparse graphs compared to traditional algorithms.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 265,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Better scalability\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 266,\n            columnNumber: 15\n          }, this), \" due to improved pruning techniques.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 266,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: \"Empirical validation\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 267,\n            columnNumber: 15\n          }, this), \" of theoretical bounds in real-world datasets.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 267,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 264,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 262,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Observation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 272,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Early benchmarks suggest that the heuristic reduces processing time significantly for larger graphs.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 273,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 271,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 233,\n    columnNumber: 5\n  }, this);\n};\n_c = Algorithm2;\nexport default Algorithm2;\nvar _c;\n$RefreshReg$(_c, \"Algorithm2\");","map":{"version":3,"names":["React","CodeEditor","jsxDEV","_jsxDEV","Algorithm2","codeSnippet","style","padding","children","fileName","_jsxFileName","lineNumber","columnNumber","code","_c","$RefreshReg$"],"sources":["C:/Users/User/OneDrive/Acads 3-2/DAA/Project/daawebsite/src/pages/algorithms/Algorithm2.js"],"sourcesContent":["// src/pages/Algorithm2.js\r\nimport React from 'react';\r\nimport CodeEditor from '../../components/CodeEditor';\r\n\r\n\r\nconst Algorithm2 = () => {\r\n  const codeSnippet = `#include<iostream>\r\n#include<set>\r\n#include<vector>\r\n#include<fstream>\r\n#include<algorithm>\r\n#include<unordered_map>\r\n#include<unordered_set>\r\n\r\nusing namespace std;\r\n\r\nclass MaximalCliques {\r\nprivate:\r\n    unordered_map<int, int> nodeId;\r\n    unordered_map<int, int> reverseNodeId;\r\n    vector<unordered_set<int>> graph;\r\n    vector<int> degenMap;\r\n    vector<int> degenOrder;\r\n\r\n    // Stats\r\n    int largestClique = 0;\r\n    long long int cliques = 0;\r\n    clock_t startTime, endTime;\r\n    double elapsedTime;\r\n    unordered_map<int, int> cliqueFreq;\r\n\r\npublic:\r\n    MaximalCliques(unordered_map<int, int>& nodeId, unordered_map<int, int>& reverseNodeId, vector<unordered_set<int>>& graph) \r\n        : nodeId(nodeId), reverseNodeId(reverseNodeId), graph(graph) {}\r\n\r\n    void degeneracyOrdering() {\r\n        int nodes = graph.size();\r\n        degenMap.resize(nodes);\r\n        vector<int> degree(nodes);\r\n        set<pair<int, int>> order;\r\n\r\n        for (int i = 0; i < nodes; i++) {\r\n            degree[i] = graph[i].size();\r\n            order.insert({degree[i], i});\r\n        }\r\n\r\n        int idx = 0;\r\n        while (!order.empty()) {\r\n            int v = order.begin()->second;\r\n            order.erase(order.begin());\r\n\r\n            degenOrder.push_back(v);\r\n            degenMap[v] = idx++;\r\n\r\n            for (int neighbor : graph[v]) {\r\n                if (order.count({degree[neighbor], neighbor})) {\r\n                    order.erase({degree[neighbor], neighbor});\r\n                    degree[neighbor]--;\r\n                    order.insert({degree[neighbor], neighbor});\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    int Tomita(const vector<int> &P, const vector<int> &X) {\r\n        int pivot = -1, maxCount = -1;\r\n\r\n        for (int u : P) {\r\n            int count = 0;\r\n            for (int v : P) {\r\n                if (graph[u].count(v)) count++;\r\n            }\r\n            if (count > maxCount) {\r\n                maxCount = count;\r\n                pivot = u;\r\n            }\r\n        }\r\n    \r\n        for (int u : X) {\r\n            int count = 0;\r\n            for (int v : P) {\r\n                if (graph[u].count(v)) count++;\r\n            }\r\n            if (count > maxCount) {\r\n                maxCount = count;\r\n                pivot = u;\r\n            }\r\n        }\r\n        return pivot;\r\n    }\r\n\r\n    void BronKerboschPivot(vector<int> &P, vector<int> &R, vector<int> &X) {\r\n        if (P.empty() && X.empty()) {\r\n            // Stat updates\r\n            int cliqueSize = (int)R.size();\r\n\r\n            largestClique = max(largestClique, cliqueSize);\r\n            cliques++;\r\n            cliqueFreq[cliqueSize]++;\r\n\r\n            cout << \"Maximal Clique Found: \" << cliques << \"\\n\";\r\n            return;\r\n        }\r\n\r\n        int u = Tomita(P, X);\r\n\r\n        vector<int> P_copy = P;\r\n        for (int v : P_copy) {\r\n            if (graph[u].find(v) == graph[u].end()) {\r\n                vector<int> P_new, X_new;\r\n                for (int w : P) {\r\n                    if (graph[v].find(w) != graph[v].end()) {\r\n                        P_new.push_back(w);\r\n                    }\r\n                }\r\n                for (int w : X) {\r\n                    if (graph[v].find(w) != graph[v].end()) {\r\n                        X_new.push_back(w);\r\n                    }\r\n                }\r\n\r\n                R.push_back(v);\r\n                BronKerboschPivot(P_new, R, X_new);\r\n                R.pop_back();\r\n\r\n                P.erase(find(P.begin(), P.end(), v));\r\n                X.push_back(v);\r\n            }\r\n        }\r\n    }\r\n\r\n    void BronKerboschDegeneracy() {\r\n        degeneracyOrdering();\r\n        for (int node : degenOrder) {\r\n            vector<int> P, X;\r\n            for (int neighbor : graph[node]) {\r\n                if (degenMap[neighbor] > degenMap[node]) {\r\n                    P.push_back(neighbor);\r\n                } else {\r\n                    X.push_back(neighbor);\r\n                }\r\n            }\r\n\r\n            vector<int> R = {node};\r\n            BronKerboschPivot(P, R, X);\r\n        }\r\n    }\r\n\r\n    void TimeAlgorithm() {\r\n        startTime = clock();\r\n        BronKerboschDegeneracy();\r\n        endTime = clock();\r\n        elapsedTime = double(endTime - startTime) / CLOCKS_PER_SEC;\r\n\r\n        cout << \"Total time taken: \" << elapsedTime << \" seconds\\n\";\r\n        cout << \"Largest clique size: \" << largestClique << \"\\n\";\r\n        cout << \"Total number of maximal cliques: \" << cliques << \"\\n\";\r\n        cout << \"Clique frequency distribution:\\n\";\r\n        for (const auto& entry : cliqueFreq) {\r\n            cout << \"Size \" << entry.first << \": \" << entry.second << \"\\n\";\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    int datasetId;\r\n    cout << \"Please select the dataset you want to use:\" << endl;\r\n    cout << \"1. Wiki-Vote\" << endl;\r\n    cout << \"2. Email-Enron\" << endl;\r\n    cout << \"3. Skitter\" << endl;\r\n\r\n    cin >> datasetId;\r\n\r\n    string filename;\r\n\r\n    switch (datasetId) {\r\n        case 1:\r\n            cout << \"Loading Wiki-Vote dataset...\" << endl;\r\n            filename = \"Dataset/Wiki-Vote.txt\";\r\n            break;\r\n        case 2:\r\n            cout << \"Loading Email-Enron dataset...\" << endl;\r\n            filename = \"Dataset/Email-Enron.txt\";\r\n            break;\r\n        case 3:\r\n            cout << \"Loading Skitter dataset...\" << endl;\r\n            filename = \"Dataset/as-skitter.txt\";\r\n            break;\r\n        default:\r\n            cout << \"Invalid dataset selection\" << endl;\r\n            return 1;\r\n    }\r\n\r\n    ifstream file(filename);\r\n    if (!file.is_open()) {\r\n        cout << \"Error opening file: \" << filename << endl;\r\n        return 1;\r\n    }\r\n\r\n    int nodes, edges;\r\n    file >> nodes >> edges;\r\n\r\n    vector<unordered_set<int>> graph(nodes);\r\n    unordered_map<int, int> nodeId;\r\n    unordered_map<int, int> reverseNodeId;\r\n\r\n    int u, v, id = 0;\r\n    while (file >> u >> v) {\r\n        if (nodeId.find(u) == nodeId.end()) {\r\n            nodeId[u] = id;\r\n            reverseNodeId[id] = u;\r\n            id++;\r\n        }\r\n        if (nodeId.find(v) == nodeId.end()) {\r\n            nodeId[v] = id;\r\n            reverseNodeId[id] = v;\r\n            id++;\r\n        }\r\n\r\n        graph[nodeId[u]].insert(nodeId[v]);\r\n        graph[nodeId[v]].insert(nodeId[u]);\r\n    }\r\n\r\n    file.close();\r\n\r\n    MaximalCliques bk(nodeId, reverseNodeId, graph);\r\n    bk.TimeAlgorithm();\r\n\r\n    return 0;\r\n}`;\r\n\r\n  return (\r\n    <div style={{ padding: '1rem' }}>\r\n      <h1>Algorithm 2</h1>\r\n      \r\n      <section>\r\n        <h2>Overview</h2>\r\n        <p>\r\n        This project focuses on implementing and analyzing a degeneracy-based variation of the Bron-Kerbosch algorithm for maximal clique enumeration in sparse graphs. The paper by Eppstein, LÃ¶ffler, and Strash introduces a novel approach that leverages graph degeneracy to improve performance in real-world networks, many of which are naturally sparse. By optimizing the recursive search strategy and reducing unnecessary computations, the algorithm achieves a worst-case time complexity of O(dn3d/3), which is nearly optimal for sparse graphs.\r\n        </p>\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>Implementation Details</h2>\r\n        <ul>\r\n        <li><strong>Graph Representation:</strong> Store the input as an adjacency list.</li>\r\n        <li><strong>Enhanced DFS:</strong> Compute an ordering of vertices based on degeneracy.</li>\r\n        <li><strong>Modified Bron-Kerbosch Algorithm:</strong>\r\n            <ul>\r\n            <li>Iterate over vertices in degeneracy order.</li>\r\n            <li>Use the pivoting strategy to reduce recursive calls.</li>\r\n            <li>Generate and report maximal cliques efficiently.</li>\r\n            </ul>\r\n        </li>\r\n        <li><strong>Optimization:</strong> Use bitwise operations and data structures (hash maps, sets) for efficiency.</li>\r\n        </ul>\r\n\r\n        <h3>Code</h3>\r\n        <CodeEditor code={codeSnippet} />\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>Expectation</h2>\r\n        <ul>\r\n          <li><strong>Faster enumeration</strong> in sparse graphs compared to traditional algorithms.</li>\r\n          <li><strong>Better scalability</strong> due to improved pruning techniques.</li>\r\n          <li><strong>Empirical validation</strong> of theoretical bounds in real-world datasets.</li>\r\n        </ul>\r\n      </section>\r\n      \r\n      <section>\r\n        <h2>Observation</h2>\r\n        <p>\r\n          Early benchmarks suggest that the heuristic reduces processing time significantly for larger graphs.\r\n        </p>\r\n      </section>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Algorithm2;\r\n"],"mappings":";AAAA;AACA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,UAAU,MAAM,6BAA6B;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAGrD,MAAMC,UAAU,GAAGA,CAAA,KAAM;EACvB,MAAMC,WAAW,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}